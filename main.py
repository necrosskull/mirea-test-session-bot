import json
import logging
import re
import datetime
from telegram import ReplyKeyboardMarkup, ReplyKeyboardRemove
from telegram.ext import Updater, CommandHandler, MessageHandler, Filters
from decode import decode_teachers
from config import TELEGRAM_TOKEN
from lazy_logger import lazy_logger
from semester_start import get_semester_start_date_from_period

logging.basicConfig(format="%(asctime)s - %(name)s - %(levelname)s - %(message)s", level=logging.INFO)

WEEKDAYS = {
    '–ø–æ–Ω–µ–¥–µ–ª—å–Ω–∏–∫': 1,
    '–≤—Ç–æ—Ä–Ω–∏–∫': 2,
    '—Å—Ä–µ–¥–∞': 3,
    '—á–µ—Ç–≤–µ—Ä–≥': 4,
    '–ø—è—Ç–Ω–∏—Ü–∞': 5,
    '—Å—É–±–±–æ—Ç–∞': 6,
    '–≤–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ': 7
}

MONTHS = {
    1: "–Ø–Ω–≤–∞—Ä—è",
    2: "–§–µ–≤—Ä–∞–ª—è",
    3: "–ú–∞—Ä—Ç–∞",
    4: "–ê–ø—Ä–µ–ª—è",
    5: "–ú–∞—è",
    6: "–ò—é–Ω—è",
    7: "–ò—é–ª—è",
    8: "–ê–≤–≥—É—Å—Ç–∞",
    9: "–°–µ–Ω—Ç—è–±—Ä—è",
    10: "–û–∫—Ç—è–±—Ä—è",
    11: "–ù–æ—è–±—Ä—è",
    12: "–î–µ–∫–∞–±—Ä—è"
}

GROUP_PATTERN = r'[–ê-–Ø–∞-—è]{4}-\d{2}-\d{2}'
EXAM_PATTERN = r'—ç–∫–∑ (.+)|–≠–∫–∑ (.+)|–≠–ö–ó (.+)'


def load_exams_from_file():
    with open('data/test_session.json', 'r', encoding='utf-8') as f:
        exams = json.load(f)
    return exams


exams = load_exams_from_file()


def start(update, context):
    context.bot.send_message(chat_id=update.effective_chat.id,
                             text="–ü—Ä–∏–≤–µ—Ç!\n–ù–∞ –ø–µ—Ä–∏–æ–¥ —Å–µ—Å—Å–∏–∏ –≤–∫–ª—é—á–µ–Ω —Ä–µ–∂–∏–º —Å–µ—Å—Å–∏–∏.\n\n"
                                  "–î–æ—Å—Ç—É–ø–µ–Ω –ø–æ–∏—Å–∫ –ø–æ –ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª—è–º –∏ –≥—Ä—É–ø–ø–∞–º.\n"
                                  "–í–≤–µ–¥–∏ —Ñ–∞–º–∏–ª–∏—é –ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª—è –∏–ª–∏ –≥—Ä—É–ø–ø—É.\n\n"
                                  "–ü—Ä–∏–º–µ—Ä—ã: \n"
                                  "`–ò–≤–∞–Ω–æ–≤ –ò.–ê.`\n"
                                  "`–ò–≤–∞–Ω–æ–≤`\n"
                                  "`–ò–í–ë–û-07-22`", parse_mode='Markdown')


def search(update, context):
    query = update.message.text
    mode = determine_search_mode(query)

    if mode == 'teacher':
        query = prepare_teacher_query(query)
    elif mode == 'group':
        query = query.lower()

    if len(query) < 3:
        context.bot.send_message(chat_id=update.effective_chat.id, text="–°–ª–∏—à–∫–æ–º –∫–æ—Ä–æ—Ç–∫–∏–π –∑–∞–ø—Ä–æ—Å")
        return

    lazy_logger.info(json.dumps({"type": "request", "query": query.lower(), **update.message.from_user.to_dict()},
                                ensure_ascii=False))

    exam_ids = find_exam_ids(query, exams, mode)

    if not exam_ids:
        context.bot.send_message(chat_id=update.effective_chat.id,
                                 text="–ü–æ –≤–∞—à–µ–º—É –∑–∞–ø—Ä–æ—Å—É –Ω–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ")
        return

    unique_exams = create_unique_exams(exam_ids, exams)
    sorted_exams = sort_exams(unique_exams)

    if mode == 'teacher':
        context.user_data['teacher'] = query
        surnames_count = check_same_surnames(sorted_exams, update, context)
        if surnames_count:
            return

    send_exam_info(update, context, sorted_exams, mode)


def check_same_surnames(sorted_exams, update, context):
    surnames = list(set([exam[1]['teacher'] for exam in sorted_exams]))
    surnames_str = ', '.join(decode_teachers(surnames))
    for surname in surnames:
        if context.user_data['teacher'] == surname.lower():
            return
    surnames_count = len(surnames)
    if surnames_count > 1:
        keyboard = [[surname] for surname in surnames]
        reply_markup = ReplyKeyboardMarkup(keyboard, one_time_keyboard=True)
        context.bot.send_message(chat_id=update.effective_chat.id,
                                 text=f"–ü–æ –∑–∞–ø—Ä–æ—Å—É ({context.user_data['teacher'][:-1].title()}) –Ω–∞–π–¥–µ–Ω–æ –Ω–µ—Å–∫–æ–ª—å–∫–æ "
                                      f"–ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª–µ–π:\n\n({surnames_str})"
                                      f"\n\n–£—Ç–æ—á–Ω–∏—Ç–µ –∑–∞–ø—Ä–æ—Å:",
                                 reply_markup=reply_markup)
        return surnames_count


def determine_search_mode(query):
    if re.match(GROUP_PATTERN, query):
        return 'group'
    return 'teacher'


def prepare_teacher_query(query):
    if " " not in query:
        query += " "
    return query.lower()


def find_exam_ids(query, exams, mode):
    if mode == 'teacher':
        exam_ids = [exam_id for exam_id, teacher in exams['teachers'].items() if query in teacher.lower()]
    else:
        exam_ids = [exam_id for exam_id, group in exams['group'].items() if query == group.lower()]
    return exam_ids


def create_unique_exams(exam_ids, exams):
    unique_exams = {}
    for exam_id in exam_ids:
        key = (exams['weekday'][exam_id], exams['time_start'][exam_id], exams['weeks'][exam_id])
        if key in unique_exams:
            unique_exams[key]['group'].append(exams['group'][exam_id])
        else:
            unique_exams[key] = {
                'exam': exams['lesson'][exam_id],
                'group': [exams['group'][exam_id]],
                'num': exams['lesson_num'][exam_id],
                'teacher': exams['teachers'][exam_id],
                'room': exams['room'][exam_id] if exams['room'][exam_id] else "",
                'campus': exams['campus'][exam_id][0] if exams['campus'][exam_id] else "",
                'weekday': exams['weekday'][exam_id],
                'weeks': exams['weeks'][exam_id],
                'time_start': exams['time_start'][exam_id],
                'time_end': exams['time_end'][exam_id],
                'type': exams['type'][exam_id] if exams['type'][exam_id] else ""
            }
    return unique_exams


def sort_exams(unique_exams):
    return sorted(unique_exams.items(), key=lambda x: (x[1]['weeks'], WEEKDAYS[x[1]['weekday']], x[1]['time_start']))


def send_exam_info(update, context, sorted_exams, mode):
    chunks = []
    chunk = ""

    for exam in sorted_exams:
        exam_info = format_exam_info(exam, mode)
        if len(chunk) + len(exam_info) <= 4096:
            chunk += exam_info
        else:
            chunks.append(chunk)
            chunk = exam_info

    if chunk:
        chunks.append(chunk)

    for chunk in chunks:
        context.bot.send_message(chat_id=update.effective_chat.id, text=chunk, reply_markup=ReplyKeyboardRemove())


def format_exam_info(exam, mode):
    exam_info = ""
    groups = ', '.join(exam[1]['group'])
    weekday = exam[1]['weekday'].title()
    time_start = exam[1]['time_start']
    time_end = exam[1]['time_end']
    weeks = exam[1]['weeks']
    campus = exam[1]['campus']
    room = exam[1]['room']
    teacher = exam[1]['teacher']
    teachers = ", ".join(decode_teachers([teacher]))
    lesson = exam[1]['exam']
    num = exam[1]['num']
    time_start = datetime.datetime.strptime(time_start, "%H:%M:%S").strftime("%H:%M")
    time_end = datetime.datetime.strptime(time_end, "%H:%M:%S").strftime("%H:%M")

    if weeks.isdigit():

        semester_start = get_semester_start_date_from_period()
        int_weekday = WEEKDAYS.get(weekday.lower())
        start_weekday = semester_start.weekday() + 1
        weekday_difference = int_weekday - start_weekday
        days_to_add = (int(weeks) - 1) * 7

        target_date = semester_start + datetime.timedelta(days=days_to_add + weekday_difference)

        month_name = MONTHS[target_date.month]
        date = target_date.day
    else:
        date = ""
        month_name = ""

    formatted_time = f"{time_start} ‚Äì {time_end}"
    exam_info += f'üìÖ –ù–µ–¥–µ–ª—è: {weeks}\n'
    exam_info += f"üìÜ –î–∞—Ç–∞: {date} {month_name}\n"
    exam_info += f"üìÜ –î–µ–Ω—å –Ω–µ–¥–µ–ª–∏: {weekday}\n"
    exam_info += f'üìù –ü–∞—Ä–∞ ‚Ññ {num} –≤ ‚è∞ {formatted_time}\n'
    exam_info += f"üè´ –ê—É–¥–∏—Ç–æ—Ä–∏–∏: {room} ({campus})\n"
    exam_info += f'üìù {lesson}\n'
    if len(groups) > 0:
        exam_info += f'üë• –ì—Ä—É–ø–ø—ã: {groups}\n'
    if exam[1]['type']:
        exam_info += f'üìö –¢–∏–ø: {exam[1]["type"]}\n'
    if len(teachers) > 0:
        exam_info += f"üë®üèª‚Äçüè´ –ü—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª–∏: {teachers}\n\n"
    else:
        exam_info += "\n"

    return exam_info


def main():
    updater = Updater(TELEGRAM_TOKEN, use_context=True)
    dp = updater.dispatcher

    dp.add_handler(CommandHandler('start', start, run_async=True))
    dp.add_handler(CommandHandler('help', start, run_async=True))
    dp.add_handler(CommandHandler('about', start, run_async=True))
    dp.add_handler(MessageHandler(Filters.text, search, run_async=True))

    updater.start_polling()
    updater.idle()


if __name__ == '__main__':
    main()
